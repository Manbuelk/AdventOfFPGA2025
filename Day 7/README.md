#Advent of FPGA 2025 Day 7

I decided to solve this by storing the amount of ways to get to columns in a ram, starting at 0(for empty columns) or 1(for the column containing the "S") in the first row. Then, as new characters are given to the module, I keep track of the column of the current character is in. There are three adder registers, right, middle and left, that are shifted from right to middle to left as new characters are processed.
When a "^" character is processed, the previous value of its column stored in the ram is added to the right and left register, when a "." is processed, it is added to the middle register. The values getting shifted out of the left register are then written back to the ram in the appropriate column and also added to a register that is reset when a new line starts that counts contains the solution for part two.
When a "^" character is processed and the previous value of the column is not 0, a counter containing the result for part one is incremented by one. The wide zero equality checks are probably not great performance wise and this would probably benefit from its own ram to store a single representing whether a column can be reached by a laser or not.
Once the input is done, the pipeline is first flushed with newline characters. The result registers are then converted to BCD using double dabble that is intended to be constrained as a multi cycle path of length BCD_CONVERSION_MULTICYCLE_LENGTH(a parameter to the module). As this only needs to be done once when the computation is finished, I don't believe that pipelining would have any benefits over a multi cycle path, but I would love to be corrected on this if it turns out to be wrong. I didn't get to test how many cycles are a reasonable amount to not bottleneck the maximum frequency of this design as I ran out of time so I made it configurable.
I also didn't have the time to actually confirm this, but in theory, for a maximum output length of 64 bits and a maximum input column amount of 512, this should fit into a single Xilinx 7 series block ram in simple dual port mode. It is however possible that this module in its current state does not correctly cause that to be inferred by Vivado.
The module has three parameters, MAX_WIDTH, which is the maximum column amount of the input, MAX_OUTPUT, which is the bitwidth of the output and also of the ram, and BCD_CONVERSION_MULTICYCLE_LENGTH, which is the length of the multi cycle path for the bcd conversion.
The pipelined ram -> registers -> ram approach I'm using here also has the consequence of needing at least two columns in the input because there needs to be a minimum amount of characters for a columns value to be written back to ram before it is read again. This should however not really be an issue in practice as most inputs should be longer than that anyways.
