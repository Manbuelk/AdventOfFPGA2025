# Advent of FPGA 2025 Day 7
I decided to solve this problem by storing the number of ways to get to columns in a ram, starting at 0 (for empty columns) or 1 (for the column containing the "S") in the first row. Then, as new characters are given to the module, I keep track of the column the current character is in. There are three adder registers, right, middle and left, that are shifted from right to middle to left as new characters are processed.\
When a "^" character is processed, the previous value of its column stored in the ram is added to the right and left register; when a "." is processed, it is added to the middle register instead. The values getting shifted out of the left register are then written back to the ram in the appropriate column and are also added to a register that is reset when a new line starts and contains the solution for part 2, once the last line has been processed.\
When a "^" character is processed and the previous value of the column is not 0, a counter containing the result for part one is incremented by one.\
Once the input is done, the pipeline is first flushed with newline characters. The result registers are then converted to BCD using double dabble that is intended to be constrained as a multi cycle path of length BCD_CONVERSION_MULTICYCLE_LENGTH (a parameter to the module). As this only needs to be done once when the computation is finished, pipelining shouldn't have any benefits over a multi cycle path. I didn't get to test how many cycles are a reasonable number to not bottleneck the maximum frequency of this design, as I ran out of time, so I made it configurable.\
I also didn't have the time to actually confirm this, but in theory, for a maximum output length of 64 bits and a maximum input column amount of 512, the column ram should fit into a single Xilinx 7 series block ram in simple dual port mode. It is, however, possible that this module, in its current state, does not correctly cause that to be inferred by Vivado.\
The module has three parameters: MAX_WIDTH, which is the maximum number of columns of the input, MAX_OUTPUT, which is the bitwidth of the output and also of the ram, and BCD_CONVERSION_MULTICYCLE_LENGTH, which is the length of the multi cycle path for the BCD conversion.\
The pipelined ram -> registers -> ram approach I'm using here also has the consequence of needing at least two columns in the input because there needs to be a minimum amount of characters for a column's value to be written back to ram before it is read again. This should, however, not really be an issue in practice, as most inputs should be longer than that in any case.


